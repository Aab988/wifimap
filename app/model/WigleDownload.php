<?php
namespace App\Model;
use Nette\Utils;
use Nette\Utils\DateTime;

/**
 * Class WigleDownload
 * @package App\Model
 *
 */
class WigleDownload extends Download implements \IDownload {

	/**
     * Source ID from DB
     */
    const ID_SOURCE = 2;
	/**
     * Maximum results returned by wigle to one query
     */
    const MAX_RESULTS_COUNT = 500;

    /**
     * name of cookie file
     */
    const COOKIE_FILE = "cookie.txt";

    /**
     * Wigle login URL
     */
    const WIGLE_LOGIN_URL = "https://wigle.net/api/v1/jsonLogin";

	/**
	 * Wigle download data URL
	 */
	const WIGLE_GETDATA_URL = "https://wigle.net/api/v1/jsonSearch";

	/**
	 * Wigle download overlay image URL
	 */
	const WIGLE_IMAGE_OVERLAY_URL = "https://wigle.net/gps/gps/GPSDB/onlinemap2/";

    /**
     * Wigle QOS grad color image URL
     */
    const WIGLE_QOS_GRAD_IMAGE_URL = "https://wigle.net/images/qos_grad.png";

	/**
	 * Wigle web url
	 */
	const WIGLE_URL = "https://wigle.net";

    // error/info return constants
    const ERR_ALREADY_IN_QUEUE = "ALREADY_IN_QUEUE";
    const ERR_RECENTLY_DOWNLOADED = "RECENTLY_DOWNLOADED";
    const INFO_ADDED_TO_QUEUE = "ADDED_TO_QUEUE";

	/**
     * @var string Wigle login
     */
    private $user = "";
    /**
     * @var string Wigle password
     */
    private $password = "";


    /**
     * @var array coords generated by cron queue creation script
     */
	private $generatedCoords = array();

    /**
     * @var array wigle wifi colors
     */
    private $wigleNetColors = array();

    /**
     * create and exec CURL request
     *
     * @param string $url
     * @param array $params associative array, key - param name, value - param value
     * @param bool|true $withCookie
     * @param bool $withHeader
     * @return mixed CURL result
     */
	private function sendCurlRequest($url,$params,$withCookie = true,$withHeader = false) {
		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL,$url);
		curl_setopt($ch, CURLOPT_POSTFIELDS,http_build_query($params));
        if($withHeader) {
            curl_setopt($ch, CURLOPT_HEADER, true);
        }
		curl_setopt($ch, CURLOPT_COOKIESESSION, true);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
		curl_setopt($ch, CURLOPT_SSL_VERIFYHOST,  2);
		if($withCookie) {
			curl_setopt ($ch, CURLOPT_COOKIEJAR, self::COOKIE_FILE);
			curl_setopt ($ch, CURLOPT_COOKIEFILE, self::COOKIE_FILE);
		}
		$result = curl_exec($ch);
		curl_close ($ch);
		return $result;
	}


    /**
     * get colors from wigle net qos grad image
     */
    private function fillWigleNetColors() {
        $image = imagecreatefrompng(self::WIGLE_QOS_GRAD_IMAGE_URL);
        for($x = 0; $x< 100; $x++) {
            for($y = 0; $y<12; $y++) {
                $color = dechex(imagecolorat($image, $x,$y));
                if(!in_array($color,$this->wigleNetColors)) {
                    $this->wigleNetColors[] = $color;
                }
            }
        }
		$this->wigleNetColors[] = "ff0000";
		$this->wigleNetColors[] = "00ff00";
    }


	/**
	 * Login to Wigle and save cookie
	 */
    private function loginToWigle() {
		$this->sendCurlRequest(self::WIGLE_LOGIN_URL,array("credential_0"=>$this->user,"credential_1"=>$this->password));
    }


    /**
     * @param float $longmin
     * @param float $longmax
     * @param float $latmin
     * @param float $latmax
     * @param int $first
     * @return string JSON with Wigle data
     */
    private function getDataFromWigle($longmin, $longmax, $latmin, $latmax, $first = 0) {
        $arr = array(
            "longrange1"=>$longmin,
            "longrange2"=>$longmax,
            "latrange1"=>$latmin,
            "latrange2"=>$latmax
        );
        if($first != 0) {
            $arr["first"] = $first;
            $arr["last"] = $first + 99;
        }
		return $this->sendCurlRequest(self::WIGLE_GETDATA_URL,$arr);
    }

    /**
     * @param array $line
     * @return Wifi
     */
    public function parseLine($line) {
        $wifi = new Wifi();

        $wifi->setMac($line['netid']);
        $wifi->setSsid(($line['ssid']) ? $line['ssid'] : "");
        $wifi->setComment(trim($line['comment']));
        $wifi->setName(trim($line['name']));
        $wifi->setType($line['type']);
        $wifi->setFreenet($line['freenet']);
        $wifi->setPaynet($line['paynet']);
        $wifi->setFirsttime(new DateTime($line['firsttime']));
        $wifi->setLasttime(new DateTime($line['lasttime']));
        $wifi->setFlags($line['flags']);
        $wifi->setWep($line['wep']);
        $wifi->setLatitude((double)$line['trilat']);
        $wifi->setLongitude((double)$line['trilong']);
        $wifi->setLastupdt($line['lastupdt']);
        $wifi->setChannel((int)$line['channel']);
        $wifi->setBcninterval($line['bcninterval']);
        $wifi->setQos((int)$line['qos']);
        $wifi->setSource(self::ID_SOURCE);

        return $wifi;
    }

    /**
     * main method, performed by CRON
     */
    public function download() {
        $this->loginToWigle();
        $query = $this->database->table("download_queue")->select("id,lat_start,lat_end,lon_start,lon_end,from,to")
            ->where("downloaded = ?", 0)
            ->order("rand()")
            ->limit(1)
            ->fetch();

        $lon_start = doubleval($query['lon_start']);
        $lon_end = doubleval($query['lon_end']);
        $lat_start = doubleval($query['lat_start']);
        $lat_end = doubleval($query['lat_end']);

        $results = $this->getDataFromWigle($lon_start, $lon_end, $lat_start, $lat_end, (int) $query["from"]);

        $results_decoded = json_decode($results,true);

        if($results_decoded["success"] == true) {
            $ws = $this->parseData($results_decoded);
            $this->saveAll($ws);
            $this->database->table("download_queue")
				->where("id = ?", $query["id"])
                ->update(array("downloaded"=>1,"downloaded_nets_count"=>count($ws)));

            if((int)$results_decoded["resultCount"] == 100) {
                $this->database->query("insert into download_queue", array(
                    "id_source" => self::ID_SOURCE,
                    "lat_start" => $lat_start,
                    "lat_end" => $lat_end,
                    "lon_start" => $lon_start,
                    "lon_end" => $lon_end,
                    "downloaded" => 0,
                    "from" => (int)$results_decoded["last"],
                    "to" => (int) $results_decoded["last"] + 99
                ));
            }
        }
        else {
            echo "too many queries";
        }

	}

    /**
     * @param $data decoded JSON
     * @return Wifi[]
     */
    private function parseData($data) {
        $ws = array();
        foreach($data["results"] as $net) {
            $ws[] = $this->parseLine($net);
        }
        return $ws;
    }

	/**
	 * divide big area into smaller ones by counted sites density
	 *
	 * @param float $lat_start
	 * @param float $lat_end
	 * @param float $lon_start
	 * @param float $lon_end
	 */
    public function generateLatLngDownloadArray($lat_start,$lat_end,$lon_start,$lon_end) {
        $this->fillWigleNetColors();


		//dump($this->wigleNetColors);
		// rounding to 2 decimal points
        $lat_start = round($lat_start-0.005,2); $lat_end = round($lat_end+0.005,2);
        $lon_start = round($lon_start-0.005,2); $lon_end = round($lon_end+0.005,2);

		$coords = $this->divideLatLngInitially($lat_start, $lat_end, $lon_start, $lon_end);

		$i = 0;
        foreach($coords as $key=>$ar) {
            $coords[$key] = $this->improveLatLngRange($ar["lat_start"],$ar["lat_end"],$ar["lon_start"],$ar["lon_end"]);
			$i++;
			$this->database->query("insert into log", array(
				"operation" => "wiglecrongeneration",
				"data" => $ar["lat_start"]."|".$ar["lat_end"]."|".$ar["lon_start"]."|".$ar["lon_end"],
				"procent" => ($i / (double)count($coords)) * 100
			));
        }
		$this->iterateArray($coords);
        $this->saveAll2downloadQueue();
    }

	/**
	 * save all generated coords into DB
	 */
    private function saveAll2downloadQueue() {
        foreach($this->generatedCoords as $coord) {
            $coord['id_source'] = self::ID_SOURCE;
            $coord['downloaded'] = 0;

            $this->database->query("insert into download_queue", $coord);
        }
    }


	/**
	 * recursively search whole array and create array from each quads
	 *
	 * @param array $nestedCoords nested array -> nesting = quad segmentation
	 */
	private function iterateArray($nestedCoords) {
        foreach($nestedCoords as $c) {
            if(is_array($c) && !$this->isAssoc($c)) {
                $this->iterateArray($c);
            }
            else {
				$this->generatedCoords[] = $c;
            }
        }
    }

	/**
	 * return if array is associative
	 *
	 * @param array $array
	 * @return bool
	 */
    private function isAssoc($array) {
        $return = true;
        foreach(array_keys($array) as $a) {
            $return = $return & is_string($a);
        }
        return (bool)$return;
    }

	/**
	 *
	 * recursively creating array of quads with less nets to download
	 * each nesting = quad segmentation to 4 smaller quads
	 *
	 * @param float $lat_start
	 * @param float $lat_end
	 * @param float $lon_start
	 * @param float $lon_end
	 * @return array
	 */
    private function improveLatLngRange($lat_start,$lat_end,$lon_start,$lon_end) {
		$coords = array();
        $count = $this->analyzeImage($lat_start,$lat_end,$lon_start,$lon_end);
		$this->database->query("insert into log", array(
			"operation" => "vypocetbarev",
			"data" => $count,
			"procent" => 0
		));
        if($count > self::MAX_RESULTS_COUNT) {

			$this->database->query("insert into log", array(
				"operation" => "zanoreni",
				"data" => $count,
				"procent" => 0
			));
            for($lat = round($lat_start,6); round($lat,6) < round($lat_end,6); $lat += ($lat_end - $lat_start)/2.0) {
                for ($lon = round($lon_start,6); round($lon,6) < round($lon_end,6); $lon += ($lon_end - $lon_start) / 2.0) {

					$nlat = ($lat + ($lat_end - $lat_start) / 2.0);
					$nlon = ($lon + ($lon_end - $lon_start) / 2.0);

					$nlat = ($nlat <= $lat_end) ? $nlat : $lat_end;
					$nlon = ($nlon <= $lon_end) ? $nlon : $lon_end;

                    $coords[] = $this->improveLatLngRange($lat, $nlat,$lon, $nlon);
                }
            }
        }
        else {
            $coords = array("lat_start"=>$lat_start,"lat_end"=>$lat_end,"lon_start"=>$lon_start,"lon_end"=>$lon_end, 'calculated_nets_count'=>$count);
		}
        return $coords;
    }


    /**
     * return number of nets on Wigle overlay Image
     *
     * @param float $lat_start
     * @param float $lat_end
     * @param float $lon_start
     * @param float $lon_end
     * @return int
     */
    private function analyzeImage($lat_start,$lat_end,$lon_start,$lon_end) {

        if($lat_end < $lat_start) {	$tmp = $lat_start;	$lat_start = $lat_end;	$lat_end = $tmp; }
        if($lon_end < $lon_start) { $tmp = $lon_start;	$lon_start = $lon_end;	$lon_end = $tmp; }

		$params = array(
			"lat1"=>$lat_start,
			"long1"=>$lon_start,
			"lat2"=>$lat_end,
			"long2"=>$lon_end,
			"redir"=>"Y",
			"networksOnly"=>"Y",
			"sizeX"=>256,
			"sizeY"=>256
		);
		$url = self::WIGLE_IMAGE_OVERLAY_URL . "?". http_build_query($params);

        $headers = get_headers($url,1);

        $url = self::WIGLE_URL.trim($headers["Location"]);
        $image = imagecreatefrompng($url);

        $points = 0;
        for($x = 0; $x< 256; $x++) {
            for($y = 0; $y<256; $y++) {
				if(in_array(dechex(imagecolorat($image, $x,$y)),$this->wigleNetColors)) {
					$points++;
				}
            }
        }
        return $points;
    }

	/**
	 * @param string $user
	 */
    public function setUser($user) {
        $this->user = $user;
    }

	/**
	 * @param string $password
	 */
    public function setPassword($password) {
        $this->password = $password;
    }

	/**
	 * do basic segmentation (by 0.05 in lat and lon range) of lat lng rectangle
	 * @param float $lat_start
	 * @param float $lat_end
	 * @param float $lon_start
	 * @param float $lon_end
	 * @return array
	 */
	public function divideLatLngInitially($lat_start, $lat_end, $lon_start, $lon_end)
	{
		$coords = array();
		for ($lat = round($lat_start, 2); round($lat, 2) < round($lat_end, 2); $lat += 0.05) {
			for ($lon = round($lon_start, 2); round($lon, 2) < round($lon_end, 2); $lon += 0.05) {

				$nlate = ($lat + 0.05 <= $lat_end) ? $lat + 0.05 : $lat_end;
				$nlone = ($lon + 0.05 <= $lon_end) ? $lon + 0.05 : $lon_end;

				$coords[] = array("lat_start" => $lat, "lat_end" => $nlate, "lon_start" => $lon, "lon_end" => $nlone);
			}
		}
		return $coords;
	}

    /**
     * adds wigle request to wigle requests queue to DB
     *
     * @param float $lat_start
     * @param float $lat_end
     * @param float $lon_start
     * @param float $lon_end
     */
    public function addWigleRequest($lat_start, $lat_end, $lon_start, $lon_end) {
        $this->database->query("insert into wigle_request", array(
            "date"=> new DateTime(),
            "lat_start" => $lat_start,
            "lat_end" => $lat_end,
            "lon_start" => $lon_start,
            "lon_end" => $lon_end,
            "processed" => 'N'
        ));
    }

    /**
     * finds if this area is already in download queue
     *
     * @param float $lat_start
     * @param float $lat_end
     * @param float $lon_start
     * @param float $lon_end
     * @return bool|mixed|\Nette\Database\Table\IRow
     */
    private function getRequestAlreadyExistingInLatLngRange($lat_start, $lat_end, $lon_start, $lon_end) {
        $query = $this->database->table("wigle_request")
            ->where("lat_start <= ?",$lat_start)
            ->where("lat_end >= ?", $lat_end)
            ->where("lon_start <= ?",$lon_start)
            ->where("lon_end >= ?", $lon_end);
        return $query->fetch();
    }

    /**
     * process wigle request and determine what to do
     * returns status code
     *
     * @param mixed|float $lat1
     * @param mixed|float $lat2
     * @param mixed|float $lon1
     * @param mixed|float $lon2
     * @return bool|string
     */
    public function processWigleRequestCreation($lat1,$lat2,$lon1,$lon2) {
        $lat1 = doubleval($lat1);
        $lat2 = doubleval($lat2);
        $lon1 = doubleval($lon1);
        $lon2 = doubleval($lon2);

        if($lat1 > $lat2) {
            $tmp = $lat1;
            $lat1 = $lat2;
            $lat2 = $tmp;
        }

        if($lon1 > $lon2) {
            $tmp = $lon1;
            $lon1 = $lon2;
            $lon2 = $tmp;
        }


        $existingRequest = $this->getRequestAlreadyExistingInLatLngRange($lat1,$lat2,$lon1,$lon2);

        if($existingRequest) {
            // nalezeno
            $er = $existingRequest->toArray();
            // pokud processed = N pak je ve frontě a neni staženo
            if($er["processed"] == "N") {
                return self::ERR_ALREADY_IN_QUEUE;
            }
            else {
                $today = new DateTime();
                $diff = $today->diff($er["processed_date"]);
                if($diff->days < 7) {
                    return self::ERR_RECENTLY_DOWNLOADED;
                }
                else {
                    $this->addWigleRequest($lat1,$lat2,$lon1,$lon2);
                    return self::INFO_ADDED_TO_QUEUE;
                }
            }
        }
        else {
            $this->addWigleRequest($lat1,$lat2,$lon1,$lon2);
            return self::INFO_ADDED_TO_QUEUE;
        }
        return false;
    }


    public function findNotInQueueRectsInLatLngRange() {
        $lat1 = 50.21605376832277;
        $lat2 = 50.23606150790367;
        $lon1 = 15.801542195377579;
        $lon2 = 15.840568481184846;

        // vzit z db všechny co se alespoň částečně nachází v tomto rozptylu
        $data = $this->database->table("wigle_request")
            ->select("lat_start,lat_end,lon_start,lon_end")
            ->where('lat_start >= ? OR lat_end <= ?', $lat1,$lat2)
            ->where('lon_start >= ? OR lon_end <= ?', $lon1,$lon2)
            ->where('processed','N')
            ->fetchAll();
        echo "DATA";
        dump($data);

        $mappingX = array($lat1,$lat2);
        $mappingY = array($lon1,$lon2);
        foreach($data as $d) {
            $lat_start = doubleval($d['lat_start']); $lat_end = doubleval($d['lat_end']);
            $lon_start = doubleval($d['lon_start']); $lon_end = doubleval($d['lon_end']);

            //echo "$lat_start - $lat_end <br />	";

            //echo "$lon_start - $lon_end <br />	";

            if(!in_array($lat_start,$mappingX) && $lat_start >= $lat1 && $lat_start <= $lat2) {
                $mappingX[] = $lat_start;
            }
            if(!in_array($lat_end,$mappingX) && $lat_end <= $lat2 && $lat_end >= $lat1) {
                $mappingX[] = $lat_end;
            }
            if(!in_array($lon_start,$mappingY) && $lon_start >= $lon1 && $lon_start <= $lon2) {
                $mappingY[] = $lon_start;
            }
            if(!in_array($lon_end,$mappingY) && $lon_end <= $lon2 && $lon_end >= $lon1) {
                $mappingY[] = $lon_end;
            }
        }
        sort($mappingX);
        sort($mappingY);

        echo "MAPPING";
        dump($mappingX);
        dump($mappingY);

// TODO: vygenerovat mapovani a vygenerovat tohle pole
        $array = array();
        for($x = 0; $x < count($mappingX)-1;$x++) {
            for($y = 0; $y < count($mappingY)-1; $y++) {

                $lat_start = $mappingX[$x];
                $lat_end = $mappingX[$x + 1];
                $lon_start = $mappingY[$y];
                $lon_end = $mappingY[$y + 1];

                $val = 0;
                foreach($data as $d) {
                    if($lat_start >= doubleval($d['lat_start']) && $lat_end <= doubleval($d['lat_end'])
                        && $lon_start >= doubleval($d['lon_start']) && $lon_end <= doubleval($d['lon_end'])) {
                        $val = 1;
                        continue;
                    }
                }
                /*if(!isset($array[$y][$x])) {
                    $array[$y][$x] = $val;
                }
                else {
                    if($array[$y][$x] != 1) {*/
                $array[$y][$x] = $val;
                /*}
            }*/
            }
        }

        /*$array = array(
            array(0,0,0,1,1,1,0),
            array(1,1,0,1,1,1,0),
            array(1,1,0,0,0,0,0),
            array(1,1,0,0,0,1,1),
            array(0,0,0,0,0,1,1),
            array(0,1,1,1,0,1,1)
        );*/
        //dump($array);
        echo "PLOCHA<br /><br />";
        for($x = 0; $x < count($array);$x++) {
            for ($y = 0; $y < count($array[$x]); $y++) {
                echo $array[$x][$y];
            }
            echo '<br />';
        }


        /*$array = array(
            array(0,0,0,1,1,1,0),
            array(1,1,0,1,1,1,0),
            array(1,1,0,0,0,0,0),
            array(1,1,0,0,0,1,1),
            array(0,0,0,0,0,1,1),
            array(0,1,1,1,0,1,1)
        );*/

        /*	$mappingX = array(50.12,50.14,50.15,50.17,50.19,50.20,50.25);
            $mappingY = array(15.81,15.83,15.84,15.85,15.87,15.88,15.90,15.95);
        */

        $rects = array();
        for($x = 0; $x < count($array); $x++) {
            $ar = array();$nul = 0; $one = 0;$from = 0;
            for($y = 0; $y < count($array[0]); $y++) {
                if($array[$x][$y] == 0) {
                    if($one > 0) {$from = $y;$one = 0;}
                    $nul++;
                }
                else {
                    if($nul > 0) {$ar[] = array("from" => $from, "to" => $from + $nul);$nul = 0;}
                    $one++;
                }
            }
            if($nul > 0) {
                $ar[] = array("from" => $from, "to" => $from + $nul);
            }
            $rects[$x] = $ar;
        }
        dump($rects);

        $unmapped = array();
        for($x = 0; $x < count($rects); $x++) {
            foreach($rects[$x] as $zero) {
                //$unmapped[] = array("x"=> array("from"=>$mappingX[$x],"to"=>$mappingX[$x+1]), "y" => array("from" => $mappingY[$zero["from"]], "to" => $mappingY[$zero["to"]]));
                $unmapped[] = array("x"=> array("from"=>$mappingX[$zero["from"]],"to"=>$mappingX[$zero['to']]), "y" => array("from" => $mappingY[$x], "to" => $mappingY[$x+1]));
            }
        }
        dump($unmapped);

    }






}