<?php
namespace App\Model;
use Nette\Utils;
use Nette\Utils\DateTime;

/**
 * Class WigleDownload
 * @package App\Model
 *
 */
class WigleDownload extends Download implements \IDownload {

	/**
     * Source ID from DB
     */
    const ID_SOURCE = 2;
	/**
     * Maximum results returned by wigle to one query
     */
    const MAX_RESULTS_COUNT = 500;

    /**
     * name of cookie file
     */
    const COOKIE_FILE = "cookie.txt";

    /**
     * Wigle login URL
     */
    const WIGLE_LOGIN_URL = "https://wigle.net/api/v1/jsonLogin";

	/**
	 * Wigle download data URL
	 */
	const WIGLE_GETDATA_URL = "https://wigle.net/api/v1/jsonSearch";

	/**
	 * Wigle download overlay image URL
	 */
	const WIGLE_IMAGE_OVERLAY_URL = "https://wigle.net/gps/gps/GPSDB/onlinemap2/";

    const WIGLE_QOS_GRAD_IMAGE_URL = "https://wigle.net/images/qos_grad.png";

	/**
	 * Wigle web url
	 */
	const WIGLE_URL = "https://wigle.net";


	/**
     * @var string Wigle login
     */
    private $user = "";
    /**
     * @var string Wigle password
     */
    private $password = "";


    /**
     * @var array coords generated by cron queue creation script
     */
	private $generatedCoords = array();

    private $wigleNetColors = array();

    /**
     * create and exec CURL request
     *
     * @param string $url
     * @param array $params associative array, key - param name, value - param value
     * @param bool|true $withCookie
     * @param bool $withHeader
     * @return mixed CURL result
     */
	private function sendCurlRequest($url,$params,$withCookie = true,$withHeader = false) {
		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL,$url);
		curl_setopt($ch, CURLOPT_POSTFIELDS,http_build_query($params));
        if($withHeader) {
            curl_setopt($ch, CURLOPT_HEADER, true);
        }
		curl_setopt($ch, CURLOPT_COOKIESESSION, true);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
		curl_setopt($ch, CURLOPT_SSL_VERIFYHOST,  2);
		if($withCookie) {
			curl_setopt ($ch, CURLOPT_COOKIEJAR, self::COOKIE_FILE);
			curl_setopt ($ch, CURLOPT_COOKIEFILE, self::COOKIE_FILE);
		}
		$result = curl_exec($ch);
		curl_close ($ch);
		return $result;
	}


    private function fillWigleNetColors() {
        $image = imagecreatefrompng(self::WIGLE_QOS_GRAD_IMAGE_URL);
        for($x = 0; $x< 100; $x++) {
            for($y = 0; $y<12; $y++) {
                $color = dechex(imagecolorat($image, $x,$y));
                if(!in_array($color,$this->wigleNetColors)) {
                    $this->wigleNetColors[] = $color;
                }
            }
        }
		$this->wigleNetColors[] = "ff0000";
		$this->wigleNetColors[] = "00ff00";
    }


	/**
	 * Login to Wigle and save cookie
	 */
    private function loginToWigle() {
		$this->sendCurlRequest(self::WIGLE_LOGIN_URL,array("credential_0"=>$this->user,"credential_1"=>$this->password));
    }


    /**
     * @param float $longmin
     * @param float $longmax
     * @param float $latmin
     * @param float $latmax
     * @param int $first
     * @return string JSON with Wigle data
     */
    private function getDataFromWigle($longmin, $longmax, $latmin, $latmax, $first = 0) {
        $arr = array(
            "longrange1"=>$longmin,
            "longrange2"=>$longmax,
            "latrange1"=>$latmin,
            "latrange2"=>$latmax
        );
        if($first != 0) {
            $arr["first"] = $first;
            $arr["last"] = $first + 99;
        }
		return $this->sendCurlRequest(self::WIGLE_GETDATA_URL,$arr);
    }

    /**
     * @param array $line
     * @return Wifi
     */
    public function parseLine($line) {
        $wifi = new Wifi();

        $wifi->setMac($line['netid']);
        $wifi->setSsid(($line['ssid']) ? $line['ssid'] : "");
        $wifi->setComment(trim($line['comment']));
        $wifi->setName(trim($line['name']));
        $wifi->setType($line['type']);
        $wifi->setFreenet($line['freenet']);
        $wifi->setPaynet($line['paynet']);
        $wifi->setFirsttime(new DateTime($line['firsttime']));
        $wifi->setLasttime(new DateTime($line['lasttime']));
        $wifi->setFlags($line['flags']);
        $wifi->setWep($line['wep']);
        $wifi->setLatitude((double)$line['trilat']);
        $wifi->setLongitude((double)$line['trilong']);
        $wifi->setLastupdt($line['lastupdt']);
        $wifi->setChannel((int)$line['channel']);
        $wifi->setBcninterval($line['bcninterval']);
        $wifi->setQos((int)$line['qos']);
        $wifi->setSource(self::ID_SOURCE);

        return $wifi;
    }

    /**
     * main method, performed by CRON
     */
    public function download() {
        $this->loginToWigle();
        $query = $this->database->table("download_queue")->select("id,lat_start,lat_end,lon_start,lon_end,from,to")
            ->where("downloaded = ?", 0)
            ->order("rand()")
            ->limit(1)
            ->fetch();

        $lon_start = doubleval($query['lon_start']);
        $lon_end = doubleval($query['lon_end']);
        $lat_start = doubleval($query['lat_start']);
        $lat_end = doubleval($query['lat_end']);

        $results = $this->getDataFromWigle($lon_start, $lon_end, $lat_start, $lat_end, (int) $query["from"]);

        $results_decoded = json_decode($results,true);

        if($results_decoded["success"] == true) {
            $ws = $this->parseData($results_decoded);
            $this->saveAll($ws);
            $this->database->table("download_queue")
				->where("id = ?", $query["id"])
                ->update(array("downloaded"=>1,"downloaded_nets_count"=>count($ws)));

            if((int)$results_decoded["resultCount"] == 100) {
                $this->database->query("insert into download_queue", array(
                    "id_source" => self::ID_SOURCE,
                    "lat_start" => $lat_start,
                    "lat_end" => $lat_end,
                    "lon_start" => $lon_start,
                    "lon_end" => $lon_end,
                    "downloaded" => 0,
                    "from" => (int)$results_decoded["last"],
                    "to" => (int) $results_decoded["last"] + 99
                ));
            }
        }
        else {
            echo "too many queries";
        }

	}

    /**
     * @param $data decoded JSON
     * @return Wifi[]
     */
    private function parseData($data) {
        $ws = array();
        foreach($data["results"] as $net) {
            $ws[] = $this->parseLine($net);
        }
        return $ws;
    }

	/**
	 * divide big area into smaller ones by counted sites density
	 *
	 * @param float $lat_start
	 * @param float $lat_end
	 * @param float $lon_start
	 * @param float $lon_end
	 */
    public function generateLatLngDownloadArray($lat_start,$lat_end,$lon_start,$lon_end) {
        $this->fillWigleNetColors();


		//dump($this->wigleNetColors);
		// rounding to 2 decimal points
        $lat_start = round($lat_start-0.005,2); $lat_end = round($lat_end+0.005,2);
        $lon_start = round($lon_start-0.005,2); $lon_end = round($lon_end+0.005,2);

		$coords = $this->divideLatLngInitially($lat_start, $lat_end, $lon_start, $lon_end);

		$i = 0;
        foreach($coords as $key=>$ar) {
            $coords[$key] = $this->improveLatLngRange($ar["lat_start"],$ar["lat_end"],$ar["lon_start"],$ar["lon_end"]);
			$i++;
			$this->database->query("insert into log", array(
				"operation" => "wiglecrongeneration",
				"data" => $ar["lat_start"]."|".$ar["lat_end"]."|".$ar["lon_start"]."|".$ar["lon_end"],
				"procent" => ($i / (double)count($coords)) * 100
			));
        }
		$this->iterateArray($coords);
        $this->saveAll2downloadQueue();
    }

	/**
	 * save all generated coords into DB
	 */
    private function saveAll2downloadQueue() {
        foreach($this->generatedCoords as $coord) {
            $coord['id_source'] = self::ID_SOURCE;
            $coord['downloaded'] = 0;

            $this->database->query("insert into download_queue", $coord);
        }
    }


	/**
	 * recursively search whole array and create array from each quads
	 *
	 * @param array $nestedCoords nested array -> nesting = quad segmentation
	 */
	private function iterateArray($nestedCoords) {
        foreach($nestedCoords as $c) {
            if(is_array($c) && !$this->isAssoc($c)) {
                $this->iterateArray($c);
            }
            else {
				$this->generatedCoords[] = $c;
            }
        }
    }

	/**
	 * return if array is associative
	 *
	 * @param array $array
	 * @return bool
	 */
    private function isAssoc($array) {
        $return = true;
        foreach(array_keys($array) as $a) {
            $return = $return & is_string($a);
        }
        return (bool)$return;
    }

	/**
	 *
	 * recursively creating array of quads with less nets to download
	 * each nesting = quad segmentation to 4 smaller quads
	 *
	 * @param float $lat_start
	 * @param float $lat_end
	 * @param float $lon_start
	 * @param float $lon_end
	 * @return array
	 */
    private function improveLatLngRange($lat_start,$lat_end,$lon_start,$lon_end) {
		$coords = array();
        $count = $this->analyzeImage($lat_start,$lat_end,$lon_start,$lon_end);
		$this->database->query("insert into log", array(
			"operation" => "vypocetbarev",
			"data" => $count,
			"procent" => 0
		));
        if($count > self::MAX_RESULTS_COUNT) {

			$this->database->query("insert into log", array(
				"operation" => "zanoreni",
				"data" => $count,
				"procent" => 0
			));
            for($lat = round($lat_start,6); round($lat,6) < round($lat_end,6); $lat += ($lat_end - $lat_start)/2.0) {
                for ($lon = round($lon_start,6); round($lon,6) < round($lon_end,6); $lon += ($lon_end - $lon_start) / 2.0) {

					$nlat = ($lat + ($lat_end - $lat_start) / 2.0);
					$nlon = ($lon + ($lon_end - $lon_start) / 2.0);

					$nlat = ($nlat <= $lat_end) ? $nlat : $lat_end;
					$nlon = ($nlon <= $lon_end) ? $nlon : $lon_end;

                    $coords[] = $this->improveLatLngRange($lat, $nlat,$lon, $nlon);
                }
            }
        }
        else {
            $coords = array("lat_start"=>$lat_start,"lat_end"=>$lat_end,"lon_start"=>$lon_start,"lon_end"=>$lon_end, 'calculated_nets_count'=>$count);
		}
        return $coords;
    }


    /**
     * return number of nets on Wigle overlay Image
     *
     * @param float $lat_start
     * @param float $lat_end
     * @param float $lon_start
     * @param float $lon_end
     * @return int
     */
    private function analyzeImage($lat_start,$lat_end,$lon_start,$lon_end) {

        if($lat_end < $lat_start) {	$tmp = $lat_start;	$lat_start = $lat_end;	$lat_end = $tmp; }
        if($lon_end < $lon_start) { $tmp = $lon_start;	$lon_start = $lon_end;	$lon_end = $tmp; }

		$params = array(
			"lat1"=>$lat_start,
			"long1"=>$lon_start,
			"lat2"=>$lat_end,
			"long2"=>$lon_end,
			"redir"=>"Y",
			"networksOnly"=>"Y",
			"sizeX"=>256,
			"sizeY"=>256
		);
		$url = self::WIGLE_IMAGE_OVERLAY_URL . "?". http_build_query($params);

        $headers = get_headers($url,1);

        $url = self::WIGLE_URL.trim($headers["Location"]);
        $image = imagecreatefrompng($url);

        $points = 0;
        for($x = 0; $x< 256; $x++) {
            for($y = 0; $y<256; $y++) {
				if(in_array(dechex(imagecolorat($image, $x,$y)),$this->wigleNetColors)) {
					$points++;
				}
            }
        }
        return $points;
    }

	/**
	 * @param string $user
	 */
    public function setUser($user) {
        $this->user = $user;
    }

	/**
	 * @param string $password
	 */
    public function setPassword($password) {
        $this->password = $password;
    }

	/**
	 * do basic segmentation (by 0.05 in lat and lon range) of lat lng rectangle
	 * @param float $lat_start
	 * @param float $lat_end
	 * @param float $lon_start
	 * @param float $lon_end
	 * @return array
	 */
	public function divideLatLngInitially($lat_start, $lat_end, $lon_start, $lon_end)
	{
		$coords = array();
		for ($lat = round($lat_start, 2); round($lat, 2) < round($lat_end, 2); $lat += 0.05) {
			for ($lon = round($lon_start, 2); round($lon, 2) < round($lon_end, 2); $lon += 0.05) {

				$nlate = ($lat + 0.05 <= $lat_end) ? $lat + 0.05 : $lat_end;
				$nlone = ($lon + 0.05 <= $lon_end) ? $lon + 0.05 : $lon_end;

				$coords[] = array("lat_start" => $lat, "lat_end" => $nlate, "lon_start" => $lon, "lon_end" => $nlone);
			}
		}
		return $coords;
	}

}