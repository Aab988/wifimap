<?php
namespace App\Model;
use Nette\Utils;
use Nette\Utils\DateTime;

/**
 * Class WigleDownload
 * @package App\Model
 *
 */
class WigleDownload extends Download implements \IDownload {

    /** Source ID from DB  */
    const ID_SOURCE = 2;

    /** Maximum results returned by wigle to one query */
    const MAX_RESULTS_COUNT = 500;

    /** name of cookie file */
    const COOKIE_FILE = "cookie.txt";

    /** Wigle login URL */
    const WIGLE_LOGIN_URL = "https://wigle.net/api/v1/jsonLogin";

    /** Wigle download data URL */
	const WIGLE_GETDATA_URL = "https://wigle.net/api/v1/jsonSearch";

    /** Wigle download overlay image URL */
	const WIGLE_IMAGE_OVERLAY_URL = "https://wigle.net/gps/gps/GPSDB/onlinemap2/";

    /** Wigle QOS grad color image URL */
    const WIGLE_QOS_GRAD_IMAGE_URL = "https://wigle.net/images/qos_grad.png";

    /** Wigle web url */
	const WIGLE_URL = "https://wigle.net";

    /** @var string Wigle login */
    private $user = "";

    /** @var string Wigle password */
    private $password = "";

    /** @var array coords generated by cron queue creation script */
	private $generatedCoords = array();

    /** @var array wigle wifi colors */
    private $wigleNetColors = array();

    /** @var DownloadQueue */
    public $downloadQueue;

    /**
     * main method, performed by CRON
     */
    public function download() {

        $this->loginToWigle();
        $query = $this->downloadQueue->getRandomNotDownloadedRecord();
        $coords = new Coords($query['lat_start'],$query['lat_end'],$query['lon_start'],$query['lon_end']);
        $results = $this->getDataFromWigle($coords, (int) $query["from"]);
        $results_decoded = json_decode($results,true);

        if($results_decoded["success"] == true) {
            $ws = $this->parseData($results_decoded);
            $this->saveAll($ws);
            $query->update(array("downloaded"=>1,"downloaded_nets_count"=>count($ws)));
            if((int)$results_decoded["resultCount"] == 100) {
                $this->downloadQueue->addRecord($coords,self::ID_SOURCE,(int)$results_decoded["last"]);
            }
        }
        else {
            echo "too many queries";
        }

    }


    /**
     * create and exec CURL request
     *
     * @param string $url
     * @param array $params associative array, key - param name, value - param value
     * @param bool|true $withCookie
     * @param bool $withHeader
     * @return mixed CURL result
     */
	private function sendCurlRequest($url,$params,$withCookie = true,$withHeader = false) {
		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL,$url);
		curl_setopt($ch, CURLOPT_POSTFIELDS,http_build_query($params));
        if($withHeader) {
            curl_setopt($ch, CURLOPT_HEADER, true);
        }
		curl_setopt($ch, CURLOPT_COOKIESESSION, true);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0);
		curl_setopt($ch, CURLOPT_SSL_VERIFYHOST,  2);
		if($withCookie) {
			curl_setopt ($ch, CURLOPT_COOKIEJAR, self::COOKIE_FILE);
			curl_setopt ($ch, CURLOPT_COOKIEFILE, self::COOKIE_FILE);
		}
		$result = curl_exec($ch);
		curl_close ($ch);
		return $result;
	}


    /**
     * get colors from wigle net qos grad image
     */
    private function fillWigleNetColors() {
        $image = imagecreatefrompng(self::WIGLE_QOS_GRAD_IMAGE_URL);
        for($x = 0; $x< 100; $x++) {
            for($y = 0; $y<12; $y++) {
                $color = dechex(imagecolorat($image, $x,$y));
                if(!in_array($color,$this->wigleNetColors)) {
                    $this->wigleNetColors[] = $color;
                }
            }
        }
		$this->wigleNetColors[] = "ff0000";
		$this->wigleNetColors[] = "00ff00";
    }


	/**
	 * Login to Wigle and save cookie
	 */
    private function loginToWigle() {
		$this->sendCurlRequest(self::WIGLE_LOGIN_URL,array("credential_0"=>$this->user,"credential_1"=>$this->password));
    }


    /**
     * @param Coords $coords
     * @param int $first
     * @return string JSON with Wigle data
     */
    private function getDataFromWigle($coords, $first = 0) {
        $arr = array(
            "longrange1"=>$coords->getLonStart(),
            "longrange2"=>$coords->getLonEnd(),
            "latrange1"=>$coords->getLatStart(),
            "latrange2"=>$coords->getLatEnd()
        );
        if($first != 0) {
            $arr["first"] = $first;
            $arr["last"] = $first + 99;
        }
		return $this->sendCurlRequest(self::WIGLE_GETDATA_URL,$arr);
    }

    /**
     * @param $data decoded JSON
     * @return Wifi[]
     */
    private function parseData($data) {
        $ws = array();
        foreach($data["results"] as $net) {
            $ws[] = $this->parseLine($net);
        }
        return $ws;
    }

    /**
     * @param array $line
     * @return Wifi
     */
    public function parseLine($line) {
        $wifi = new Wifi();

        $wifi->setMac($line['netid']);
        $wifi->setSsid(($line['ssid']) ? $line['ssid'] : "");
        $wifi->setComment(trim($line['comment']));
        $wifi->setName(trim($line['name']));
        $wifi->setType($line['type']);
        $wifi->setFreenet($line['freenet']);
        $wifi->setPaynet($line['paynet']);
        $wifi->setFirsttime(new DateTime($line['firsttime']));
        $wifi->setLasttime(new DateTime($line['lasttime']));
        $wifi->setFlags($line['flags']);
        $wifi->setWep($line['wep']);
        $wifi->setLatitude((double)$line['trilat']);
        $wifi->setLongitude((double)$line['trilong']);
        $wifi->setLastupdt($line['lastupdt']);
        $wifi->setChannel((int)$line['channel']);
        $wifi->setBcninterval($line['bcninterval']);
        $wifi->setQos((int)$line['qos']);
        $wifi->setSource(self::ID_SOURCE);

        return $wifi;
    }



	/**
	 * divide big area into smaller ones by counted sites density
	 *
     * @param Coords $coords
	 */
    public function generateLatLngDownloadArray($coords) {
        $this->fillWigleNetColors();

        // rounding to 2 decimal points
        $nc = new Coords(
            round($coords->getLatStart()-0.005,2),
            round($coords->getLatEnd()+0.005,2),
            round($coords->getLonStart()-0.005,2),
            round($coords->getLonEnd()+0.005,2)
        );

		$coords = $this->divideLatLngInitially($nc);

		$i = 0;
        foreach($coords as $key=>$ar) {
            $coords[$key] = $this->improveLatLngRange($ar);
			$i++;
			$this->database->query("insert into log", array(
				"operation" => "wiglecrongeneration",
				"data" => $ar->toString(),
				"procent" => ($i / (double)count($coords)) * 100
			));
        }
		$this->iterateArray($coords);
        $this->saveAll2downloadQueue();
    }

	/**
	 * save all generated coords into DB
	 */
    private function saveAll2downloadQueue() {
        foreach($this->generatedCoords as $coord) {
            $this->downloadQueue->addRecord($coord,self::ID_SOURCE);
        }
    }

	/**
	 * recursively search whole array and create array from each quads
	 *
	 * @param array $nestedCoords nested array -> nesting = quad segmentation
	 */
	private function iterateArray($nestedCoords) {
        foreach($nestedCoords as $c) {
            if(is_array($c) && !ArrayUtil::isAssoc($c)) {
                $this->iterateArray($c);
            }
            else {
				$this->generatedCoords[] = $c;
            }
        }
    }

	/**
	 *
	 * recursively creating array of quads with less nets to download
	 * each nesting = quad segmentation to 4 smaller quads
	 *
     * @param Coords $coords
	 * @return array
	 */
    private function improveLatLngRange($coords) {
		$nc = array();
        $count = $this->analyzeImage($coords);
		$this->database->query("insert into log", array(
			"operation" => "vypocetbarev",
			"data" => $count,
			"procent" => 0
		));
        if($count > self::MAX_RESULTS_COUNT) {

			$this->database->query("insert into log", array(
				"operation" => "zanoreni",
				"data" => $count,
				"procent" => 0
			));
            for($lat = round($coords->getLatStart(),6); round($lat,6) < round($coords->getLatEnd(),6); $lat += ($coords->getLatEnd() - $coords->getLatStart())/2.0) {
                for ($lon = round($coords->getLonStart(),6); round($lon,6) < round($coords->getLonEnd(),6); $lon += ($coords->getLonEnd() - $coords->getLonStart()) / 2.0) {

					$nlat = ($lat + ($coords->getLatEnd() - $coords->getLatStart()) / 2.0);
					$nlon = ($lon + ($coords->getLonEnd() - $coords->getLonStart()) / 2.0);

					$nlat = ($nlat <= $coords->getLatEnd()) ? $nlat : $coords->getLatEnd();
					$nlon = ($nlon <= $coords->getLonEnd()) ? $nlon : $coords->getLonEnd();

                    $nc[] = $this->improveLatLngRange(new Coords($lat, $nlat,$lon, $nlon));
                }
            }
        }
        else {
            $nc = array('coords'=>new Coords($coords->getLatStart(),$coords->getLatEnd(),$coords->getLonStart(),$coords->getLonEnd()),'calculated_nets_count'=>$count);
		}
        return $nc;
    }


    /**
     * return number of nets on Wigle overlay Image
     *
     * @param Coords $coords
     * @return int
     */
    private function analyzeImage($coords) {

		$params = array(
			"lat1"=>$coords->getLatStart(),
			"long1"=>$coords->getLonStart(),
			"lat2"=>$coords->getLatEnd(),
			"long2"=>$coords->getLonEnd(),
			"redir"=>"Y",
			"networksOnly"=>"Y",
			"sizeX"=>256,
			"sizeY"=>256
		);
		$url = self::WIGLE_IMAGE_OVERLAY_URL . "?". http_build_query($params);

        $headers = get_headers($url,1);

        $url = self::WIGLE_URL.trim($headers["Location"]);
        $image = imagecreatefrompng($url);

        $points = 0;
        for($x = 0; $x< 256; $x++) {
            for($y = 0; $y<256; $y++) {
				if(in_array(dechex(imagecolorat($image, $x,$y)),$this->wigleNetColors)) {
					$points++;
				}
            }
        }
        return $points;
    }

	/**
	 * do basic segmentation (by 0.05 in lat and lon range) of lat lng rectangle
     * @param Coords $coords
	 * @return Coords[]
	 */
	public function divideLatLngInitially($coords)
	{
		$ncoords = array();
		for ($lat = round($coords->getLatStart(), 2); round($lat, 2) < round($coords->getLatEnd(), 2); $lat += 0.05) {
			for ($lon = round($coords->getLonStart(), 2); round($lon, 2) < round($coords->getLonEnd(), 2); $lon += 0.05) {

				$nlate = ($lat + 0.05 <= $coords->getLatEnd()) ? $lat + 0.05 : $coords->getLatEnd();
				$nlone = ($lon + 0.05 <= $coords->getLonEnd()) ? $lon + 0.05 : $coords->getLonEnd();
				$ncoords[] = new Coords($lat,$nlate,$lon,$nlone);
			}
		}
		return $ncoords;
	}


    /**
     * @param string $user
     */
    public function setUser($user) {
        $this->user = $user;
    }

    /**
     * @param string $password
     */
    public function setPassword($password) {
        $this->password = $password;
    }

    /**
     * create DownloadQueue instance and set database to it
     */
    public function setDownloadQueue() {
        $this->downloadQueue = new DownloadQueue();
        $this->downloadQueue->setDatabase($this->database);
    }

}